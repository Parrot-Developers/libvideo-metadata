/**
 * Copyright (c) 2016 Parrot Drones SAS
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *   * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of the Parrot Drones SAS Company nor the
 *     names of its contributors may be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE PARROT DRONES SAS COMPANY BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "vmeta_test.h"


/**
 * This array can be generated by using the test executable with the 'dump'
 * argument. E.g.:
 * $ ./out/pdraw-linux/staging/native-wrapper.sh tst-vmeta dump
 */
static const uint8_t packed_meta[] = {
	0x50, 0x33, 0x00, 0x29, 0x00, 0x00, 0x19, 0x99, 0x00, 0x06, 0x66, 0x66,
	0x00, 0x0c, 0xcc, 0xcc, 0x01, 0xa4, 0x00, 0x0f, 0x2a, 0x00, 0x2a, 0x6b,
	0x00, 0x6b, 0x00, 0x33, 0x0b, 0xaf, 0x17, 0x5e, 0x23, 0x0d, 0x2e, 0xbd,
	0x0b, 0xaf, 0x17, 0x5e, 0x23, 0x0d, 0x2e, 0xbd, 0x0b, 0xaf, 0x17, 0x5e,
	0x23, 0x0d, 0x2e, 0xbd, 0x00, 0x4c, 0x00, 0x04, 0x20, 0x00, 0x26, 0x66,
	0x00, 0xb3, 0x00, 0xcc, 0x00, 0x00, 0x09, 0x03, 0x0a, 0x0b, 0x03, 0x04,
	0x45, 0x31, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0xde, 0x80,
	0x45, 0x33, 0x00, 0x07, 0x00, 0x06, 0x66, 0x66, 0x00, 0x0c, 0xcc, 0xcc,
	0x01, 0xa4, 0x00, 0x00, 0x00, 0x06, 0x66, 0x66, 0x00, 0x0c, 0xcc, 0xcc,
	0x01, 0xa4, 0x00, 0x00, 0x0a, 0x01, 0x00, 0x00, 0x45, 0x34, 0x00, 0x05,
	0x00, 0x03, 0x00, 0x06, 0x00, 0x09, 0x00, 0x03, 0x00, 0x06, 0x00, 0x09,
	0x00, 0x03, 0x00, 0x06, 0x00, 0x09, 0x01, 0x07, 0x45, 0x36, 0x00, 0x06,
	0x13, 0x33, 0x2c, 0xcc, 0x00, 0x06, 0x66, 0x66, 0x00, 0x0c, 0xcc, 0xcc,
	0x01, 0xa4, 0x00, 0x00, 0x00, 0x2a, 0x19, 0x99, 0x00, 0x01, 0x6b, 0x85,
};


static bool maybe(bool random)
{
	return random ? futils_randomr8_maximum(1) : 1;
}


static void fill_quaternion(struct vmeta_quaternion *quat, bool random)
{
	if (random) {
		quat->w = futils_randomrf();
		quat->x = futils_randomrf();
		quat->y = futils_randomrf();
		quat->z = futils_randomrf();
	} else {
		quat->w = 0.1f;
		quat->x = 0.2f;
		quat->y = 0.3f;
		quat->z = 0.4f;
	}
	/* Make the quaternion a unit quaternion */
	float norm = sqrtf(powf(quat->w, 2) + powf(quat->x, 2) +
			   powf(quat->y, 2) + powf(quat->z, 2));
	quat->w /= norm;
	quat->x /= norm;
	quat->y /= norm;
	quat->z /= norm;
}


static void fill_location(struct vmeta_location *loc, bool random)
{
	if (random) {
		loc->altitude_wgs84ellipsoid = NAN; /* Unused in v3 format */
		loc->altitude_egm96amsl = futils_randomrd();
		loc->latitude = futils_randomrd();
		loc->longitude = futils_randomrd();
		loc->horizontal_accuracy = futils_randomrd();
		loc->vertical_accuracy = futils_randomrd();
		loc->sv_count = futils_randomr8();
		loc->valid = futils_randomr8_maximum(1);
	} else {
		loc->altitude_wgs84ellipsoid = NAN; /* Unused in v3 format */
		loc->altitude_egm96amsl = 420.;
		loc->latitude = 0.1;
		loc->longitude = 0.2;
		loc->horizontal_accuracy = 0.3;
		loc->vertical_accuracy = 0.4;
		loc->sv_count = 15;
		loc->valid = 1;
	}
}


static void fill_ned(struct vmeta_ned *ned, bool random)
{
	if (random) {
		ned->north = futils_randomrf();
		ned->east = futils_randomrf();
		ned->down = futils_randomrf();
	} else {
		ned->north = 42.f;
		ned->east = 42.42f;
		ned->down = 0.42f;
	}
}


static void fill_thermal_spot(struct vmeta_thermal_spot *spot, bool random)
{
	if (random) {
		spot->x = futils_randomrf();
		spot->y = futils_randomrf();
		spot->temp = futils_randomrf();
		spot->value = -1; /* Unused in v3 format */
		spot->valid = futils_randomr8_maximum(1);
	} else {
		spot->x = 0.1f;
		spot->y = 0.2f;
		spot->temp = 0.3f;
		spot->value = -1; /* Unused in v3 format */
		spot->valid = 1;
	}
}


static struct vmeta_frame *unpacked_meta(bool random)
{
	int err;
	struct vmeta_frame *frame;
	err = vmeta_frame_new(VMETA_FRAME_TYPE_V3, &frame);
	CU_ASSERT_PTR_NOT_NULL(frame);
	CU_ASSERT_EQUAL(err, 0);

	{
		struct vmeta_frame_v3_base *base = &frame->v3.base;
		fill_quaternion(&base->drone_quat, random);
		fill_location(&base->location, random);
		fill_ned(&base->speed, random);
		fill_quaternion(&base->frame_base_quat, random);
		fill_quaternion(&base->frame_quat, random);
		if (random) {
			base->ground_distance = futils_randomrd();
			base->air_speed = futils_randomrf();
			base->exposure_time = futils_randomrf();
			base->gain = futils_randomr16();
			base->awb_r_gain = futils_randomrf();
			base->awb_b_gain = futils_randomrf();
			base->picture_hfov = futils_randomrf();
			base->picture_vfov = futils_randomrf();
			base->link_goodput =
				futils_randomr32_maximum((1 << 24) - 1);
			base->link_quality = futils_randomr8_maximum(5);
			base->wifi_rssi = futils_randomr8();
			base->battery_percentage = futils_randomr8();
			base->animation = futils_randomr8_maximum(1);
			base->state = futils_randomr32_maximum(
				VMETA_FLYING_STATE_EMERGENCY_LANDING);
			base->mode = futils_randomr32_maximum(
				VMETA_PILOTING_MODE_UNKNOWN);
		} else {
			base->ground_distance = 0.1;
			base->air_speed = 0.2f;
			base->exposure_time = 0.3f;
			base->gain = 4;
			base->awb_r_gain = 0.5f;
			base->awb_b_gain = 0.6f;
			base->picture_hfov = 0.7f;
			base->picture_vfov = 0.8f;
			base->link_goodput = 9;
			base->link_quality = 3;
			base->wifi_rssi = 10;
			base->battery_percentage = 11;
			base->animation = 0;
			base->state = VMETA_FLYING_STATE_FLYING;
			base->mode = VMETA_PILOTING_MODE_MAGIC_CARPET;
		}
	}

	if (maybe(random)) {
		frame->v3.has_timestamp = 1;
		struct vmeta_frame_ext_timestamp *ts = &frame->v3.timestamp;
		if (random) {
			ts->frame_timestamp =
				futils_randomr64_maximum(UINT64_MAX - 1) + 1;
		} else {
			ts->frame_timestamp = UINT64_C(42000000);
		}
	}

	if (maybe(random)) {
		frame->v3.has_automation = 1;
		struct vmeta_frame_ext_automation *automation =
			&frame->v3.automation;
		fill_location(&automation->framing_target, random);
		fill_location(&automation->flight_destination, random);
		if (random) {
			automation->followme_enabled =
				futils_randomr8_maximum(1);
			automation->lookatme_enabled =
				futils_randomr8_maximum(1);
			automation->angle_locked = futils_randomr8_maximum(1);
			automation->animation = futils_randomr32_maximum(
				VMETA_AUTOMATION_ANIM_POSITION_TWISTUP);
		} else {
			automation->followme_enabled = 1;
			automation->lookatme_enabled = 0;
			automation->angle_locked = 0;
			automation->animation =
				VMETA_AUTOMATION_ANIM_FLIP_FRONT;
		}
	}

	if (maybe(random)) {
		frame->v3.has_thermal = 1;
		struct vmeta_frame_ext_thermal *thermal = &frame->v3.thermal;
		fill_thermal_spot(&thermal->min, random);
		fill_thermal_spot(&thermal->max, random);
		fill_thermal_spot(&thermal->probe, random);
		if (random)
			thermal->calib_state = futils_randomr32_maximum(
				VMETA_THERMAL_CALIB_STATE_IN_PROGRESS);
		else
			thermal->calib_state =
				VMETA_THERMAL_CALIB_STATE_REQUESTED;
	}

	if (maybe(random)) {
		frame->v3.has_lfic = 1;
		struct vmeta_frame_ext_lfic *lfic = &frame->v3.lfic;
		fill_location(&lfic->target_location, random);
		if (random) {
			lfic->target_x = futils_randomrf();
			lfic->target_y = futils_randomrf();
			lfic->estimated_precision = futils_randomrd();
			lfic->grid_precision = futils_randomrd();
		} else {
			lfic->target_x = 0.3f;
			lfic->target_y = 0.7f;
			lfic->estimated_precision = 42.1;
			lfic->grid_precision = 1.42;
		}
	}

	return frame;
}


static void compare_base(struct vmeta_frame_v3_base *b1,
			 struct vmeta_frame_v3_base *b2)
{
	CU_ASSERT_PTR_NOT_NULL(b1);
	CU_ASSERT_PTR_NOT_NULL(b2);
	if (!b1 || !b2)
		return;

	compare_vmeta_quaternion(&b1->drone_quat, &b2->drone_quat);
	compare_vmeta_location(&b1->location, &b2->location, true);
	CU_ASSERT_DOUBLE_EQUAL(
		b1->ground_distance, b2->ground_distance, granularity(16));
	compare_vmeta_ned(&b1->speed, &b2->speed);
	CU_ASSERT_DOUBLE_EQUAL(b1->air_speed, b2->air_speed, granularity(8));
	compare_vmeta_quaternion(&b1->frame_base_quat, &b2->frame_base_quat);
	compare_vmeta_quaternion(&b1->frame_quat, &b2->frame_quat);
	CU_ASSERT_DOUBLE_EQUAL(
		b1->exposure_time, b2->exposure_time, granularity(8));
	CU_ASSERT_EQUAL(b1->gain, b2->gain);
	CU_ASSERT_DOUBLE_EQUAL(b1->awb_r_gain, b2->awb_r_gain, granularity(14));
	CU_ASSERT_DOUBLE_EQUAL(b1->awb_b_gain, b2->awb_b_gain, granularity(14));
	CU_ASSERT_DOUBLE_EQUAL(
		b1->picture_hfov, b2->picture_hfov, granularity(8));
	CU_ASSERT_DOUBLE_EQUAL(
		b1->picture_vfov, b2->picture_vfov, granularity(8));
	CU_ASSERT_EQUAL(b1->link_goodput, b2->link_goodput);
	CU_ASSERT_EQUAL(b1->link_quality, b2->link_quality);
	CU_ASSERT_EQUAL(b1->wifi_rssi, b2->wifi_rssi);
	CU_ASSERT_EQUAL(b1->battery_percentage, b2->battery_percentage);
	CU_ASSERT_EQUAL(b1->animation, b2->animation);
	CU_ASSERT_EQUAL(b1->state, b2->state);
	CU_ASSERT_EQUAL(b1->mode, b2->mode);
}


static void compare_timestamp(struct vmeta_frame_ext_timestamp *t1,
			      struct vmeta_frame_ext_timestamp *t2)
{
	CU_ASSERT_PTR_NOT_NULL(t1);
	CU_ASSERT_PTR_NOT_NULL(t2);
	if (!t1 || !t2)
		return;

	CU_ASSERT_EQUAL(t1->frame_timestamp, t2->frame_timestamp);
}


static void compare_automation(struct vmeta_frame_ext_automation *a1,
			       struct vmeta_frame_ext_automation *a2)
{
	CU_ASSERT_PTR_NOT_NULL(a1);
	CU_ASSERT_PTR_NOT_NULL(a2);
	if (!a1 || !a2)
		return;

	compare_vmeta_location(&a1->framing_target, &a2->framing_target, false);
	compare_vmeta_location(
		&a1->flight_destination, &a2->flight_destination, false);
	CU_ASSERT_EQUAL(a1->followme_enabled, a2->followme_enabled);
	CU_ASSERT_EQUAL(a1->lookatme_enabled, a2->lookatme_enabled);
	CU_ASSERT_EQUAL(a1->angle_locked, a2->angle_locked);
	CU_ASSERT_EQUAL(a1->animation, a2->animation);
}


static void compare_thermal(struct vmeta_frame_ext_thermal *t1,
			    struct vmeta_frame_ext_thermal *t2)
{
	CU_ASSERT_PTR_NOT_NULL(t1);
	CU_ASSERT_PTR_NOT_NULL(t2);
	if (!t1 || !t2)
		return;

	compare_vmeta_thermal_spot(&t1->min, &t2->min);
	compare_vmeta_thermal_spot(&t1->max, &t2->max);
	compare_vmeta_thermal_spot(&t1->probe, &t2->probe);
	CU_ASSERT_EQUAL(t1->calib_state, t2->calib_state);
}


static void compare_lfic(struct vmeta_frame_ext_lfic *l1,
			 struct vmeta_frame_ext_lfic *l2)
{
	CU_ASSERT_PTR_NOT_NULL(l1);
	CU_ASSERT_PTR_NOT_NULL(l2);
	if (!l1 || !l2)
		return;

	CU_ASSERT_DOUBLE_EQUAL(l1->target_x, l2->target_x, granularity(14));
	CU_ASSERT_DOUBLE_EQUAL(l1->target_y, l2->target_y, granularity(14));
	compare_vmeta_location(
		&l1->target_location, &l2->target_location, false);
	CU_ASSERT_DOUBLE_EQUAL(l1->estimated_precision,
			       l2->estimated_precision,
			       granularity(16));
	CU_ASSERT_DOUBLE_EQUAL(
		l1->grid_precision, l2->grid_precision, granularity(16));
}


static void meta_compare_v3(struct vmeta_frame *f1, struct vmeta_frame *f2)
{
	CU_ASSERT_PTR_NOT_NULL(f1);
	CU_ASSERT_PTR_NOT_NULL(f2);
	if (!f1 || !f2)
		return;

	CU_ASSERT_EQUAL(f1->type, VMETA_FRAME_TYPE_V3);
	CU_ASSERT_EQUAL(f2->type, VMETA_FRAME_TYPE_V3);

	compare_base(&f1->v3.base, &f2->v3.base);
	CU_ASSERT_EQUAL(f1->v3.has_timestamp, f2->v3.has_timestamp);
	if (f1->v3.has_timestamp && f2->v3.has_timestamp)
		compare_timestamp(&f1->v3.timestamp, &f2->v3.timestamp);
	CU_ASSERT_EQUAL(f1->v3.has_automation, f2->v3.has_automation);
	if (f1->v3.has_automation && f2->v3.has_automation)
		compare_automation(&f1->v3.automation, &f2->v3.automation);
	CU_ASSERT_EQUAL(f1->v3.has_thermal, f2->v3.has_thermal);
	if (f1->v3.has_thermal && f2->v3.has_thermal)
		compare_thermal(&f1->v3.thermal, &f2->v3.thermal);
	CU_ASSERT_EQUAL(f1->v3.has_lfic, f2->v3.has_lfic);
	if (f1->v3.has_lfic && f2->v3.has_lfic)
		compare_lfic(&f1->v3.lfic, &f2->v3.lfic);
}


static void meta_compare_proto(struct vmeta_frame *f1, struct vmeta_frame *f2)
{
	int err;
	const Vmeta__TimedMetadata *proto;
	CU_ASSERT_PTR_NOT_NULL(f1);
	CU_ASSERT_PTR_NOT_NULL(f2);
	if (!f1 || !f2)
		return;

	CU_ASSERT_EQUAL(f1->type, VMETA_FRAME_TYPE_V3);
	CU_ASSERT_EQUAL(f2->type, VMETA_FRAME_TYPE_PROTO);

	err = vmeta_frame_proto_get_unpacked(f2, &proto);
	CU_ASSERT_EQUAL(err, 0);
	CU_ASSERT_PTR_NOT_NULL(proto);

	CU_ASSERT_PTR_NOT_NULL(proto->drone);
	CU_ASSERT_PTR_NOT_NULL(proto->camera);
	CU_ASSERT_PTR_NOT_NULL(proto->links);
	CU_ASSERT_EQUAL(proto->n_links, 1);
	CU_ASSERT_PTR_NOT_NULL(proto->links[0]);
	CU_ASSERT_EQUAL(proto->links[0]->protocol_case,
			VMETA__LINK_METADATA__PROTOCOL_WIFI)
	Vmeta__WifiLinkMetadata *wifi = proto->links[0]->wifi;
	CU_ASSERT_PTR_NOT_NULL(wifi);

	/* Base */
	compare_vmeta_proto_quaternion(&f1->v3.base.drone_quat,
				       proto->drone->quat);
	compare_vmeta_proto_location(
		&f1->v3.base.location, proto->drone->location, true);
	CU_ASSERT_DOUBLE_EQUAL(f1->v3.base.ground_distance,
			       proto->drone->ground_distance,
			       granularity(16));
	compare_vmeta_proto_ned(&f1->v3.base.speed, proto->drone->speed);
	/* Air speed omitted in proto conversion */
	compare_vmeta_proto_quaternion(&f1->v3.base.frame_base_quat,
				       proto->camera->base_quat);
	compare_vmeta_proto_quaternion(&f1->v3.base.frame_quat,
				       proto->camera->quat);
	CU_ASSERT_DOUBLE_EQUAL(f1->v3.base.exposure_time,
			       proto->camera->exposure_time,
			       granularity(8));
	CU_ASSERT_EQUAL(f1->v3.base.gain, proto->camera->iso_gain);
	CU_ASSERT_DOUBLE_EQUAL(f1->v3.base.awb_r_gain,
			       proto->camera->awb_r_gain,
			       granularity(14));
	CU_ASSERT_DOUBLE_EQUAL(f1->v3.base.awb_b_gain,
			       proto->camera->awb_b_gain,
			       granularity(14));
	/* hfov/vfov are in radians in proto, degrees in v3 */
	CU_ASSERT_DOUBLE_EQUAL(f1->v3.base.picture_hfov,
			       proto->camera->hfov * 180. / M_PI,
			       granularity(8));
	CU_ASSERT_DOUBLE_EQUAL(f1->v3.base.picture_vfov,
			       proto->camera->vfov * 180. / M_PI,
			       granularity(8));
	CU_ASSERT_EQUAL(f1->v3.base.link_goodput, wifi->goodput);
	CU_ASSERT_EQUAL((uint8_t)f1->v3.base.link_quality, wifi->quality);
	CU_ASSERT_EQUAL(f1->v3.base.wifi_rssi, wifi->rssi);
	CU_ASSERT_EQUAL(f1->v3.base.battery_percentage,
			proto->drone->battery_percentage);
	CU_ASSERT_EQUAL(f1->v3.base.animation,
			proto->drone->animation_in_progress);
	compare_flying_state(f1->v3.base.state, proto->drone->flying_state);
	compare_piloting_mode(f1->v3.base.mode, proto->drone->piloting_mode);

	/* Timestamp */
	if (f1->v3.has_timestamp) {
		CU_ASSERT_EQUAL(f1->v3.timestamp.frame_timestamp,
				proto->camera->timestamp);
	} else {
		CU_ASSERT_EQUAL(0, proto->camera->timestamp);
	}

	/* Automation */
	if (f1->v3.has_automation) {
		CU_ASSERT_PTR_NOT_NULL(proto->automation);
		compare_vmeta_proto_location(&f1->v3.automation.framing_target,
					     proto->automation->target_location,
					     false);
		compare_vmeta_proto_location(
			&f1->v3.automation.flight_destination,
			proto->automation->destination,
			false);
		CU_ASSERT_EQUAL(f1->v3.automation.followme_enabled,
				proto->automation->follow_me);
		CU_ASSERT_EQUAL(f1->v3.automation.lookatme_enabled,
				proto->automation->lookat_me);
		CU_ASSERT_EQUAL(f1->v3.automation.angle_locked,
				proto->automation->angle_locked);
		compare_animation_enum(f1->v3.automation.animation,
				       proto->automation->animation);

	} else {
		CU_ASSERT_PTR_NULL(proto->automation);
	}

	/* Thermal */
	if (f1->v3.has_thermal) {
		CU_ASSERT_PTR_NOT_NULL(proto->thermal);
		compare_vmeta_proto_thermal_spot(&f1->v3.thermal.min,
						 proto->thermal->min);
		compare_vmeta_proto_thermal_spot(&f1->v3.thermal.max,
						 proto->thermal->max);
		compare_vmeta_proto_thermal_spot(&f1->v3.thermal.probe,
						 proto->thermal->probe);
		compare_thermal_calib_state(f1->v3.thermal.calib_state,
					    proto->thermal->calibration_state);
	} else {
		CU_ASSERT_PTR_NULL(proto->thermal);
	}

	/* Lfic */
	if (f1->v3.has_lfic) {
		CU_ASSERT_PTR_NOT_NULL_FATAL(proto->lfic);
		CU_ASSERT_FATAL(proto->n_lfic > 0);
		CU_ASSERT_PTR_NOT_NULL_FATAL(proto->lfic[proto->n_lfic - 1]);

		CU_ASSERT_DOUBLE_EQUAL(f1->v3.lfic.target_x,
				       proto->lfic[proto->n_lfic - 1]->x,
				       granularity(14));
		CU_ASSERT_DOUBLE_EQUAL(f1->v3.lfic.target_y,
				       proto->lfic[proto->n_lfic - 1]->y,
				       granularity(14));
		compare_vmeta_proto_location(
			&f1->v3.lfic.target_location,
			proto->lfic[proto->n_lfic - 1]->location,
			false);
		if (f1->v3.lfic.target_location.valid &&
		    proto->lfic[proto->n_lfic - 1]->location) {
			CU_ASSERT_DOUBLE_EQUAL(
				f1->v3.lfic.estimated_precision,
				proto->lfic[proto->n_lfic - 1]
					->location->horizontal_accuracy,
				granularity(16));
			CU_ASSERT_DOUBLE_EQUAL(
				f1->v3.lfic.estimated_precision,
				proto->lfic[proto->n_lfic - 1]
					->location->vertical_accuracy,
				granularity(16));
		}
		CU_ASSERT_DOUBLE_EQUAL(
			f1->v3.lfic.grid_precision,
			proto->lfic[proto->n_lfic - 1]->grid_precision,
			granularity(16));
		CU_ASSERT_EQUAL(VMETA__LFIC_TYPE__LFIC_TYPE_COT,
				proto->lfic[proto->n_lfic - 1]->type);

	} else {
		CU_ASSERT_PTR_NULL(proto->lfic);
	}

	err = vmeta_frame_proto_release_unpacked(f2, proto);
	CU_ASSERT_EQUAL(err, 0);
}


static void test_write(void)
{
	struct vmeta_frame *frame = NULL;
	const size_t buflen = 1024;
	uint8_t *buf = NULL;
	struct vmeta_buffer vb;
	int res;

	frame = unpacked_meta(0);
	CU_ASSERT_PTR_NOT_NULL(frame);

	buf = malloc(buflen);
	CU_ASSERT_PTR_NOT_NULL(buf);
	vmeta_buffer_set_data(&vb, buf, buflen, 0);

	res = vmeta_frame_write(&vb, frame);
	CU_ASSERT_EQUAL(res, 0);
	CU_ASSERT_EQUAL(vb.pos, sizeof(packed_meta));
	CU_ASSERT_EQUAL(memcmp(buf, packed_meta, sizeof(packed_meta)), 0);

	free(buf);
	vmeta_frame_unref(frame);
}


static void test_read(void)
{
	struct vmeta_frame *frame, *ref;
	struct vmeta_buffer vb;
	int err;

	vmeta_buffer_set_cdata(&vb, packed_meta, sizeof(packed_meta), 0);

	ref = unpacked_meta(0);
	CU_ASSERT_PTR_NOT_NULL(ref);
	err = vmeta_frame_read2(&vb, VMETA_FRAME_V3_MIME_TYPE, 0, &frame);
	CU_ASSERT_PTR_NOT_NULL(frame);
	CU_ASSERT_EQUAL(err, 0);

	meta_compare_v3(ref, frame);
	compare_vmeta_frame_getters(ref, frame);
	compare_vmeta_frame_v3_getters(frame);

	vmeta_frame_unref(frame);
	vmeta_frame_unref(ref);
}


static void test_read_proto(void)
{
	struct vmeta_frame *frame, *ref;
	struct vmeta_buffer vb;
	int err;

	vmeta_buffer_set_cdata(&vb, packed_meta, sizeof(packed_meta), 0);

	ref = unpacked_meta(0);
	CU_ASSERT_PTR_NOT_NULL(ref);
	err = vmeta_frame_read(&vb, VMETA_FRAME_V3_MIME_TYPE, &frame);
	CU_ASSERT_PTR_NOT_NULL(frame);
	CU_ASSERT_EQUAL(err, 0);

	meta_compare_proto(ref, frame);
	compare_vmeta_frame_getters(ref, frame);

	vmeta_frame_unref(frame);
	vmeta_frame_unref(ref);
}


static void test_write_read_once(void)
{
	struct vmeta_frame *in, *out;
	uint8_t *buf;
	const size_t buflen = 1 * 1024 * 1024; /* 1M should be enough */
	struct vmeta_buffer vb;
	int res, err;

	buf = malloc(buflen);
	CU_ASSERT_PTR_NOT_NULL(buf);
	vmeta_buffer_set_data(&vb, buf, buflen, 0);

	in = unpacked_meta(1);
	CU_ASSERT_PTR_NOT_NULL(in);

	res = vmeta_frame_write(&vb, in);
	CU_ASSERT_EQUAL(res, 0);

	vb.len = vb.pos;
	vb.pos = 0;
	err = vmeta_frame_read2(&vb, VMETA_FRAME_V3_MIME_TYPE, 0, &out);
	CU_ASSERT_PTR_NOT_NULL(out);
	CU_ASSERT_EQUAL(err, 0);

	meta_compare_v3(in, out);
	compare_vmeta_frame_getters(in, out);
	compare_vmeta_frame_v3_getters(out);

	free(buf);
	vmeta_frame_unref(in);
	vmeta_frame_unref(out);
}


static void test_write_read(void)
{
	/* Since write_read test is random, do it multiple times */
	for (int i = 0; i < MONKEY_TEST_COUNT; i++)
		test_write_read_once();
}


static void test_write_read_once_proto(void)
{
	struct vmeta_frame *in, *out, *proto;
	uint8_t *buf;
	const size_t buflen = 1 * 1024 * 1024; /* 1M should be enough */
	struct vmeta_buffer vb;
	int res, err;

	buf = malloc(buflen);
	CU_ASSERT_PTR_NOT_NULL(buf);
	vmeta_buffer_set_data(&vb, buf, buflen, 0);

	in = unpacked_meta(1);
	CU_ASSERT_PTR_NOT_NULL(in);

	res = vmeta_frame_write(&vb, in);
	CU_ASSERT_EQUAL(res, 0);

	vb.len = vb.pos;
	vb.pos = 0;
	err = vmeta_frame_read2(&vb, VMETA_FRAME_V3_MIME_TYPE, 0, &out);
	CU_ASSERT_PTR_NOT_NULL(out);
	CU_ASSERT_EQUAL(err, 0);
	vb.pos = 0;
	err = vmeta_frame_read(&vb, VMETA_FRAME_V3_MIME_TYPE, &proto);
	CU_ASSERT_PTR_NOT_NULL(out);
	CU_ASSERT_EQUAL(err, 0);

	meta_compare_v3(in, out);
	compare_vmeta_frame_getters(in, out);
	compare_vmeta_frame_v3_getters(out);
	meta_compare_proto(out, proto);
	compare_vmeta_frame_getters(out, proto);

	free(buf);
	vmeta_frame_unref(in);
	vmeta_frame_unref(out);
	vmeta_frame_unref(proto);
}


static void test_write_read_proto(void)
{
	/* Since write_read test is random, do it multiple times */
	for (int i = 0; i < MONKEY_TEST_COUNT; i++)
		test_write_read_once_proto();
}


static void test_read_write(void)
{
	struct vmeta_frame *tmp;
	uint8_t *buf;
	const size_t buflen = 1024;
	struct vmeta_buffer in, out;
	int err;

	buf = malloc(buflen);
	CU_ASSERT_PTR_NOT_NULL(buf);
	vmeta_buffer_set_data(&out, buf, buflen, 0);
	vmeta_buffer_set_cdata(&in, packed_meta, sizeof(packed_meta), 0);

	err = vmeta_frame_read2(&in, VMETA_FRAME_V3_MIME_TYPE, 0, &tmp);
	CU_ASSERT_PTR_NOT_NULL(tmp);
	CU_ASSERT_EQUAL(err, 0);

	err = vmeta_frame_write(&out, tmp);
	CU_ASSERT_EQUAL(err, 0);

	CU_ASSERT_EQUAL(in.len, out.pos);
	CU_ASSERT_EQUAL(memcmp(in.data, out.data, in.len), 0);

	free(buf);
	vmeta_frame_unref(tmp);
}


static void gen_packed_meta(void)
{
	int res = 0;
	const size_t buflen = 1024;
	uint8_t *buf = NULL;
	struct vmeta_buffer vb;

	struct vmeta_frame *ref = unpacked_meta(0);
	CU_ASSERT_PTR_NOT_NULL_FATAL(ref);

	buf = malloc(buflen);
	CU_ASSERT_PTR_NOT_NULL(buf);
	vmeta_buffer_set_data(&vb, buf, buflen, 0);

	res = vmeta_frame_write(&vb, ref);
	CU_ASSERT_EQUAL(res, 0);

	fprintf(stderr, "\n\n/* **** V3 **** */\n");
	fprintf(stderr, "static const uint8_t packed_meta[] = {\n\t");
	for (size_t i = 0; i < vb.pos; i++) {
		fprintf(stderr, "0x%02x,", buf[i]);
		if ((i % 12) == 11 && i < (vb.pos - 1))
			fprintf(stderr, "\n\t");
		else if (i < (vb.pos - 1))
			fprintf(stderr, " ");
	}
	fprintf(stderr, "\n};\n\n");

	free(buf);
	vmeta_frame_unref(ref);
}


CU_TestInfo s_v3_tests[] = {
	{(char *)"vmeta write", &test_write},
	{(char *)"vmeta read", &test_read},
	{(char *)"vmeta convert", &test_read_proto},
	{(char *)"vmeta read->write", &test_read_write},
	CU_TEST_INFO_NULL,
};

CU_TestInfo s_v3_monkey[] = {
	{(char *)"vmeta write->read monkey tests", &test_write_read},
	{(char *)"vmeta convert monkey tests", &test_write_read_proto},
	CU_TEST_INFO_NULL,
};

CU_TestInfo s_v3_gen[] = {
	{(char *)"vmeta packed_meta generation", &gen_packed_meta},
	CU_TEST_INFO_NULL,
};
